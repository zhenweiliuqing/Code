
子数组 一次遍历 O(n) 
状态：dp[i] 表示包含i的最大结果
转移：1.满足要求 dp[i] = dp[i-1] + 1   2.不满足要求 自己独立 或者 从0开始
53 最大连续子数组和 152 乘积最大连续子数组 1800 最大升序子数组和

状态：dp[i][j] 表示str[i-j]是否为回文子串 或 str1[0-i] str2[0-j]公共子串长度
转移：1.满足要求 dp[i][j] = dp[i-1][j-1] + 2/1   2.不满足要求 dp[i][j] = 0 重新开始
5 最长回文子串 NC127 最长公共子串
都需要在每一个更新的dp状态那里更新最大值 ans = max(ans, dp[i]/dp[i][j]);
根据状态定义 dp[n]/dp[m][n]不一定是答案

子序列 O(n2) 
状态：dp[i] 表示包含i的最大结果
转移：从0-i遍历找到满足要求的 dp[i] = max(dp[j] + 1, dp[i]);  子序列需要以i为标杆 与0-i的数据进行比较 确定dp[i]
300 最长上升子序列  376 最长摆动序列
根据状态定义 dp[n]/dp[m][n]不一定是答案


二维dp 同理 子串要求连续 子序列不要求连续 
状态：dp[i][j] 表示str1 与 str2最长的结果 是递增的 dp[m][n]就是最大的
转移：1.当str[i] == str[j]时 dp[i][j] = dp[i-1][j-1] + 2/1  2.不相等从dp[i-1][j] dp[i][j-1]中选个大的
516 最长回文子序列  1143 最长公共子序列

状态：dp[i][j] word1[0-i] 转成 word2[0-j] 的最少操作数
转移：1. 替换 dp[i- 1][j - 1] + 1
      2. 删除 增加 dp[i - 1][j] / dp[i][j - 1] + 1
      3. 不变 dp[i - 1][j - 1]
72 编辑距离
根据状态定义 dp[m][n]就是答案