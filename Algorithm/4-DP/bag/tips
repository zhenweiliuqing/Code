01背包
基础转移方程
dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i]);
一维转移方程
for i = 1 to N
    for w = W to wt[i]
        dp[w] = max(dp[w], dp[w-wt[i]] + val[i]);
必须从后往前递推，因为dp[w-wt[i]]存的就是dp[i-1]的值
如果从前往后，dp[w-wt[i]]存的就是dp[i]的值，与状态转移不符
循环顺序不能互换，必须保证用的i-1的状态。

初始化时细节：
若要求恰好装满dp[0] = 0, 其余为-NAN
只是求最大值则 dp = 0

///////////////////////////////////////////////////////////

完全背包
基础转移方程
dp[i][w] = max(dp[i-1][w], dp[i][w-wt[i]] + val[i])
一维转移方程
for i = 1 to N
    for w = wt[i] to W
        dp[w] = max(dp[w], dp[w-wt[i]] + val[i]);
01背包保证物品只选一次，现在可选无限件，必须把第i件物品也考虑进来。
根据状态转移，只能从前往后推。
值得一提的是，上述循环顺序可以颠倒。

颠倒这个问题还是没想明白,硬币不能颠倒,最好还是别颠倒了.